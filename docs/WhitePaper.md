# INTMAX のホワイトペーパー翻訳

[ホワイトペーパー](https://eprint.iacr.org/2023/1082.pdf)を頑張って翻訳して内容を理解するのが目標！！

ステートレスな RollUp が他のレイヤー 2 系のプロジェクトと異なるという点を理解する。

ゼロ知識証明を利用した RollUp 分散型アグリゲータ

## イントロ

ブロックチェーンエコシステムが絶えず進化するにつれて、ブロックチェーンの緊急性も高まっています。
スケーリング・ソリューションが急務となっている。
全体的なスループットを向上させるブロックチェーンスケーリングソリューションが急務となっている。レイヤー 2（L2）技術、特にロールアップは、これらの課題を克服するための極めて重要なツールとして登場し、そのため注目を集めています。
これらの課題を克服するための極めて重要なツールとして登場し、大きな注目を集めています。その中でも、ゼロ知識ロールアップ（または ZK ロールアップ）は、そのユニークな機能により大きな期待を集めている。
は、オンチェーンで迅速かつ安価に検証できる単一の証明に多数のトランザクションをバンドルする独自の機能により、大きな可能性を示している。
既存の ZK-rollups は、その計算コストを
既存の ZK-rollups は、計算コストを基礎となるレイヤー 1（L1）ブロックチェーンから引き離すことに成功しているものの、利用者の残高を検証するために必要なデータがすべて
ユーザーの残高を検証するために必要なデータは、すべて L1 上に掲載されなければならないという事実によって制限されている。この
このデータには、典型的なシナリオでは、トランザクションの送信者、トークンのインデックス、金額、受信者が含まれる。
トークンのインデックス、金額、そして各取引の受取人である。
したがって、ロールアップがサポートできる 1 秒あたりのトランザクション数は制限される。

### 1.1 データの可用性

ブロックチェーンの基本的なボトルネックは、データの可用性と呼ばれるものである。データの可用性とは、口座残高のような現在の状態を証明するために、取引データが利用可能である必要があることを意味する。
ブロックチェーンの口座残高のような現在の状態を証明するためには、取引データが利用可能でなければならない。
ブロックチェーンの現在の状態を証明するためには、取引データが利用可能でなければならない。これはレイヤー 1 のブロックチェーンでもロールアップでも問題となる。レイヤー
レイヤー 1 ブロックチェーンは通常、すべての取引データ
ノードがブロックチェーンを有効とみなすためには、すべての取引データが公開されている必要がある。ロールアップ
は、基礎となるブロックチェーンのデータ可用性を活用することでデータ可用性を実現し、すべてのトランザクションデータが L1 にポストされることを要求する（例えば、イーサリアムでは calldata や blob データを使用する）。このデータは大規模なノード間で複製される必要があるため、利用可能なデータ量には限界がある。
ブロックチェーンやロールアップが利用できる 1 秒あたりのトランザクション数が制限される。
ブロックチェーンやロールアップがサポートできる 1 秒あたりのトランザクション数には限界がある。スマート・コントラクト・ブロックチェーンでは
スマート・コントラクト・ブロックチェーンでは完全な取引データを提供する必要があるかもしれないが
単純な支払いトランザクションでは、次のようなコミットメントを利用可能にするだけでよいことが判明した。
ブロック内のトランザクションのセットに対するコミットメント（メルクル木のルートなど）、
コミットメントに署名した送信者のセットとともに、以下のことを確認する必要がある。
コミットメントに署名した送信者の集合とともに利用できるようにすればよい。その後、ユーザーは
ユーザーは、送信したトランザクションの包含証明と、十分なトランザクションの包含証明および ZK 証明を組み合わせることで、自分の残高のゼロ知識証明（ZK 証明）を生成することができる。
と、トランザクションの送信者がオフチェーンで提供する、受信した各トランザクションの十分な残高の ZK 証明とを組み合わせることにより、自身の残高の ZK 証明を生成することができる。我々のロールアップ・デザインはこの方法
を用いることで、既存の代替案と比較してスループットの向上を達成する。加えて、この設計は、リーダー選出やブロック構築者間の協調を必要とせず、並列に起こりうるパーミッションのないブロック構築を可能にする。
を必要としない。ブロック構築者はトランザクションの正当性を検証しないので、完全にステートレスにすることができる、
ブロック構築者はトランザクションの有効性を検証しないので、完全にステートレスで、非常にシンプルで検閲に強い
ロールアップ設計を可能にする。

### 1.2 我々の貢献

Intmax2 は、効率的でステートレスなロールアップ・デザインである：

- 既存のどのロールアップよりも少ないオンチェーンデータを使用し、イーサリアム上で毎秒 7500 トランザクションバッチを上限とする。
  イーサリアム上で毎秒 7500 トランザクション・バッチを上限とする。
  各トランザクションバッチは無制限のトークンを無制限の受信者に転送できる。
  の受信者に転送できる。
- パーミッションレスのブロック生成を提供。
- 従来の ZK ロールアップよりも強力なプライバシー特性を提供します。

## 2 簡略化された設計の説明

このセクションでは、ZK プルーフを使用しない簡略化した設計について説明する。
ZK プルーフを使用しない。この簡略化された設計は低いオンチェーンデータ消費量(トランザクション送信者当たり 4-5 バイト
5 バイト)を実現するが、それ以外は非効率的であり、プライベートでもない。
セクション 4 では、効率とプライバシーを達成するために ZK-proof を設計に追加する。
プライバシーを実現する。

### 2.1 Overview

簡略化されたデザインは、おおよそ次のように機能する。設計の中心にあるのは
プログラム可能なブロックチェーン（イーサリアムなど）上に展開されたロールアップ契約。
ロールアップに資金を預けるには、ユーザーは単に資金を受取人の L2 アドレスとともに
をロールアップ・コントラクトに送るだけである。
コントラクトはそのコントラクト・ストレージに入金を記録する。ロールアップ上で資金を移動するには、L2
口座のサブセットは、まずそのトランザクションを単一のアグリゲータに送信する。
アグリゲータはそのトランザクションをメルクルツリーのリーフに挿入する。次に、アグリゲータは
は各送信者に、その送信者のトランザクションのメルクル・ルートとメルクル・プルーフを送信する。
を送信する。その後、各送信者は公開 BLS 鍵でメルクルルートに署名し
で署名し、この署名をアグリゲータに送り返す。次に、アグリゲータは署名を 1 つの集約された署名に集約し、マルクルルート、集約された署名、およびリストを送信する。
ルート、アグリゲートされた署名、およびアグリゲートされた署名に含まれる 送信者の公開鍵のリストを、アグリゲータに送信する。
をロールアップコントラクトに送る。ロールアップ
その後、ロールアップ・コントラクトは署名を検証し、ルート、署名、送信者リスト
のリストをストレージに追加する。その後、各送信者はトランザクションのマルクル証明を各トランザクション受信者に送信する責任を負う。
をオフチェーンで各取引の受信者に送る責任がある。
送信者がその取引のために十分な残高を持っていたことを証明する、以前のマルクル証明と一緒に。
の残高を証明する。自分の残高を証明するために、各ユーザは以下を追跡する必要がある。
を追跡する必要がある。この
残高証明と呼ばれるこのメルクル証明のコレクションは、ユーザーが L1 に資金を引き出したいときに、ロールアップコントラクトに送られる。
次に、簡略化された設計について詳しく説明する。

### 2.8 リプレイ攻撃と遅延ブロック公開からの保護

悪意のあるアグリゲーターが行える攻撃には、以下のようなものがある。
がある。攻撃の一種は遅延ブロック発行である。
悪意のあるアグリゲータは、転送ブロックをパブリッシュする前に長い時間待機する、
これはライブ性の問題を引き起こす。第 2 の攻撃はリプレイ攻撃である。
リプレイ攻撃とは、悪意のあるアグリゲータが同じ転送ブロックを複数回発行することで、送信者の残高を消耗させる攻撃である。
送信者の残高を消耗させる。これらの攻撃に対する防御をプロトコル内で追加する代わりに
イン・プロトコルではなく、アウト・オブ・プロトコルで行うことができる。
ユーザーにアグリゲータを信頼させるために、アグリゲータは以下のような制限を自らに課すことができる。
L1 に中継者契約を導入することで、これらの攻撃を禁止する。ユーザーのサブセットがこの
アグリゲーターはまず、転送ブロックの期限を、それほど遠くない将来
を選ぶ。この期限を受け入れたユーザは、この期限をエクストラデータとして、中継契約アドレスをアグリゲータとして、転送プロトコルに入力する。
をアグリゲータとする。転送ブロックを構築した後、アグリゲータはそれを L
を、コントラクトによってホワイトリストに登録された L1 アドレスからリレイヤーコントラクトに送信する（フロントランニング保護のため）。転送ブロックを受信すると、
フィールドが現在時刻より遅くないことを確認してから、転送ブロックをロールアップ契約
に転送する。これにより、ブロック公開の遅延を防ぐことができる。さらに、リレイヤコントラクトは、ロールアップコントラクトに転送した最後の ブロックのタイムスタンプを保存する。
さらに、中継コントラクトは、ロールアップコントラクトに転送した最後の ブロックのタイムスタンプを保存し、新しい各転送ブロックが以下のタイムスタンプ を持つことを検証する。
転送する前に、各転送ブロックのタイムスタンプが最後に転送されたブロックより厳密に大きいことを検証する。
を検証する。これにより、リプレイ攻撃から保護される。

## 3 データ使用量と圧縮

このセクションでは、我々の設計のスケーラビリティを分析し、さらにスケーラビリティを高めるために圧縮を追加する方法を説明する。
を説明する。スケーラビリティの主なボトルネックは
スケーラビリティの主なボトルネックは転送ブロックのサイズである：

- アグリゲーターの L1 アドレス（イーサリアムでは 20 バイト）
- エクストラデータ文字列（32 バイト）
- 認証済みディクショナリー・コミットメント（メルクルツリーであれば 32 バイト
  ルート)
- ブロック内の送信者のサブセット S⊂K2（｜ S ｜ ×96 バイト（BLS 公開鍵のリストとしてエンコードされた場合
  BLS 公開鍵のリスト)
- 集約された署名(BLS 署名の場合は 48 バイト)
  10 E. Rybakken et al.
  これにより、｜ S ｜ × 96 + 132 バイトの転送ブロック・サイズが得られる。これは従来のロールアップよりも小さい。
  これは従来のロールアップの場合よりも小さい。
  ブロックに含まれる。また、従来のロールアップとは異なり、我々のブロックサイズは送信者数のみに依存し、トランザクション数には依存しない。これは
  つまり、送信者は任意の数の受信者とトランザクション・バッチを送信することができる。
  の受信者を、転送ブロックのサイズに影響を与えることなく送ることができる。
  スケーラビリティをさらに向上させるために、我々が紹介した中継コントラクトを使用して、プロトコ ル外のブロック圧縮を追加することができる。

スケーラビリティをさらに向上させるために、セクション 2.8 で紹介したリレ ー契約を使用して、プロトコル外のブロック圧縮を追加することができる。
セクション 2.8 で紹介したリレー契約を使って、プロトコル外のブロック圧縮を追加することができる。
アグリゲータは圧縮された転送ブロックをリレー契約に送る。
を解凍してからロールアップコントラクトに中継する。単純な圧縮アルゴリズム
アルゴリズムは次のように動作する。ユーザーは自分のプ

公開 BLS 鍵を
をアグリゲータのリレー契約と交換し、短いインクリメンタル ID を受け取る。リレー
契約は、ID を BLS 公開鍵にマップする辞書をストレージに格納する。
そして、アグリゲータが中継契約へ転送ブロックを送信する際、アグリゲータはその短い ID を送信する。
は公開鍵の代わりに送信者の短い ID を送信する。中継契約は
中継契約はその辞書で各 ID を検索し、公開鍵で転送ブロックを再構築する。
を公開鍵で再構築してからロールアップ・コントラクトに送信する。ID のサイズは
ID のサイズは、辞書内の ID の総数に依存する。例として
100 億アドレス（現在の世界人口より多い）をサポートするためには、各 ID は
log2
(109
)≒33 ビット ≒4.15 バイトでなければならない、
となり、ブロックサイズは｜ S ｜ ×4.15 ＋ 132 バイト程度となる。イーサリアムで実装した場合
イーサリアムで実装した場合、1 ブロックあたり 0.375 MB のデータ[18]を提供し、ブロックは 12 秒ごと[1]にやってくる。
12 秒ごとにブロックが来る[1]。
0.375 × 106 - 132
4.15
≈ 90000
L1 ブロックあたりの送信者数、つまり 1 秒あたりの送信者数は 7500 人である。この数は
イーサリアムがさらなるスケーリングを追加した場合、この数は増加する。18]によると、ゴールは以下の通りです。
ブロックあたり ≈16 MB を達成することで、毎秒 ≈320000 の送信者を可能にする。

4 プライバシーと効率の追加
セクション 2 で説明した単純化されたデザインはプライバシーに欠けている。
また、残高証明が大規模で検証コストがかかるため（特に引き出し時のオンチェーン）、効率性にも欠ける。本セクションでは
を追加する。
4.1 ロールアップ・コントラクトの状態の変更と
ブロック
まず、ロールアップ・コントラクトを変更し、ロールアップに追加されたすべてのブロッ
ブロックのリストを格納する代わりに、履歴のルートのリストを格納する。

## 3 データ使用と圧縮

このセクションでは、私たちの設計のスケーラビリティを分析し、さらにスケーラビリティを向上させるための圧縮方法について説明します。スケーラビリティの主なボトルネックは転送ブロックのサイズであり、以下のように分解されます：

アグリゲーターの L1 アドレス（Ethereum では 20 バイト）
追加データの文字列（32 バイト）
認証された辞書コミットメント（メルクルツリーのルートであれば 32 バイト）
ブロック内の送信者の部分集合 S ⊂ K2（リストとしてエンコードされた BLS 公開鍵のリストの場合、|S| × 96 バイト）
集約署名（BLS 署名で 48 バイト）
これにより、転送ブロックのサイズは |S| × 96 + 132 バイトになります。ここで、|S| はブロック内の送信者の数です。これは、すべての取引の詳細（送信者、受信者、取引額など）をブロックに含める従来のロールアップよりも小さいです。また、従来のロールアップとは異なり、ブロックサイズは取引の数ではなく、送信者の数にのみ依存します。これにより、送信者は任意の数の受信者に対して取引バッチを送信しても、転送ブロックのサイズには影響を与えません。

さらにスケーラビリティを向上させるために、セクション 2.8 で紹介したリレーコントラクトを使用して、プロトコル外でブロック圧縮を追加できます。アグリゲーターは圧縮された転送ブロックをリレーコントラクトに送信し、リレーコントラクトはこれらのブロックを展開してからロールアップコントラクトに中継します。簡単な圧縮アルゴリズムは以下のように機能します。ユーザーは自分の公開 BLS 鍵をアグリゲーターのリレーコントラクトに登録し、短い増分 ID を受け取ります。リレーコントラクトは、ID を BLS 公開鍵にマッピングする辞書をそのストレージに保存します。その後、アグリゲーターがリレーコントラクトに転送ブロックを送信するとき、送信者の公開鍵の代わりに短い ID を送信します。リレーコントラクトは辞書で各 ID を参照し、公開鍵で転送ブロックを再構築してからロールアップコントラクトに送信します。ID のサイズは辞書内の総 ID 数に依存します。例えば、100 億のアドレス（現在の世界人口を超える数）をサポートするためには、各 ID は log2(10^9) ≈ 33 ビット ≈ 4.15 バイトとなります。これにより、ブロックサイズは約 |S| × 4.15 + 132 バイトになります。

Ethereum では、ブロックごとに 0.375 MB のデータが提供され、ブロックは 12 秒ごとに生成されるため、理論上の限界は約

0.375
×
1
0
6
−
132
4.15
≈
90000
4.15
0.375×10
6
−132
​
≈90000
L1 ブロックごとの送信者、または 1 秒あたり 7500 送信者となります。この数は、Ethereum がさらにスケーリングを追加すると増加します。目標は約 16 MB のデータをブロックごとに提供することであり、これにより約 320000 送信者を 1 秒あたりサポートできるようになります。

## 4 プライバシーと効率性の追加

セクション 2 で説明した簡略化された設計にはプライバシーが欠けており、取引の受取人が意図しない他の取引に関する情報を得ることができ、効率性も欠けています。特に引き出し時の残高証明が大きく、検証に高コストがかかります。このセクションでは、再帰的な ZK 証明を使用してプライバシーと効率性を追加します。

### 4.1 ロールアップコントラクトの状態とブロック追加手順の変更

まず、ロールアップコントラクトはすべての追加されたブロックのリストを保存する代わりに、各ルートが {0, 1}ⁿ のハッシュダイジェストである履歴ルートのリスト、および各 L1 アカウントに引き出された総額をマッピングするマッピングを保存するように変更されます：

Scontract := ({0, 1}ⁿ)\* × VK1+.

もし ((rooti)i∈[N], withdrawn) がコントラクトの現在の状態であり、B ∈ B がロールアップに追加される新しいブロックである場合、コントラクトは以下のように新しいブロックを追加します。ブロックが預金ブロックまたは転送ブロックである場合、コントラクトは最新の履歴ルートと新しいブロックのハッシュ H(rootN, B) を計算し、この新しい履歴ルートを履歴ルートのリストに追加します。新しいブロックが引き出しブロックである場合、引き出された金額が引き出された金額の現在のマップに追加されます：

withdrawn ← withdrawn + B.

### 4.2 転送プロトコルの変更

転送ブロックの構築と追加に関するフェーズ 1 はセクション 2.6 で説明されている通りですが、残高証明の管理と配布に関するフェーズ 2 は以下のように変更されます。送金者 s が受取人 r に資金を送る際、（簡略化された設計のように）送金者や他のユーザーの完全な取引履歴を提供するのではなく、(root, s, r, v, π) というタプルだけを送信します。ここで、

root ∈ {0, 1}ⁿ は取引を含むロールアップブロックの履歴ルートです
s ∈ K2 は送金者の L2 アドレスです
r ∈ K は受取人のアドレスです
v ∈ V+ は取引金額です
π は取引の有効性証明で、これは送金者 s が受取人 r に取引金額 v の取引を行ったこと、その取引が履歴ハッシュ root のロールアップブロックに含まれていること、そして送金者がその取引を行うのに十分な残高を持っていたことを示す ZK 証明です
この方法により、受取人はこの取引についてのみ知ることができ、送金者の残高や他の取引については全く知ることができません。

取引の有効性証明を作成するために、各ユーザーは以下のデータを維持する必要があります：

送信したすべての取引バッチ（オンチェーンの転送ブロックに含まれているもの）とそれに対応するソルトおよびルックアップ証明
他のユーザーから受け取ったすべての確認済み取引（ハッシュ、s、r、v、π）
これらのデータとロールアップに追加されたブロックのリストを持つことで、各ユーザーは自身の取引の有効性証明を生成することができます。

### 4.3 引き出しプロトコルの変更

L1 アカウントの所有者がロールアップ内の残高を L1 に引き出したい場合、L1 アドレス address ∈ K1、値 v ∈ V+、履歴ルート root ∈ {0, 1}n、および address が履歴ルート root においてロールアップ内で少なくとも v を受け取ったことを示す ZK 証明を含む引き出しリクエストをロールアップコントラクトに送信します。引き出しリクエストを受け取ると、ロールアップコントラクトは ZK 証明が有効であり、root がそのストレージ内の履歴ルートのリストに含まれていることを確認します。これらのチェックが有効であれば、コントラクトは address の以前に引き出された額を v から差し引いて、L1 アカウントのロールアップ内残高を計算します。そして、コントラクトは計算された残高を L1 に引き出し、ストレージ内の引き出された総額を更新します。

## 5 結論

従来の ZK ロールアップ・アプローチから完全にシフトした、新しい ZK ロールアップ・アプローチである Intmax2(ステートレスロールアップ) を紹介した。
従来のアプローチとは対照的に、我々のソリューションは、すべてのトランザクションデータを基礎となる L1
を必要としないため、前例のないスケーラビリティを実現できる。アグリゲーターが
アグリゲーターが計算集約的な
ゼロ知識証明を実行する必要がなく、その代わりに計算をシステム内のユーザー側に移動させることで、我々の設計は、システム内のユーザー側に計算を移動させることなく、システム内のユーザー側に計算を移動させることを可能にする。
私たちのデザインは、L2 スケーリングに対する斬新で実用的かつ回復力のあるソリューションを提供します。最後に、アグリゲーターの役割を完全に無許可にすることで
を完全に無許可にすることで、我々のデザインは、より検閲に強いソリューションを可能にし、ロールアップ空間における既存の主な問題の 1 つに対処している。

## 以下、藤本さんの X のポストより

Plasma Next について日本語で簡単に説明すると、 Intmax には各トランザクションに対して、５バイトのオンチェーン データしかなく、その５バイトに数千のトランザクションを含めることができます。Plasma Next の payment channel は、その 5 バイトを多くの送信者と共有できます。だから言葉通り「ほぼゼロ」のガスコストが Ethereum 上で実現できるんです。そして、なんと Plasma Next の payment channel には online requirements が必要ありません！この点は Lightning Network に詳しい人こそ、注目して下さり、反応やコメントを頂きました。

## 動画からわかったこと

INTMAX の場合はユーザー側(クライアント側でも ZKproof を生成するようにしている。)  
レイヤー 1 の方にデータを保持させない(ステートフルにさせない設計にしている。)

INTMAX の ZKP は、**infinite recursive zkp**

一個前の Proof を検証することで、帰納的に全ての ZKP のチェーンを検証可能。

Client Side Validation に使うことで、Stateless の力を最大化

⇨ 無制限の並列化が可能になる。
⇨ 他にこの考え方を取り入れているのが Mina Protocol
