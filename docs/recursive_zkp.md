# 再帰的 ZK 証明（Recursive ZK-proofs）について

これから再帰的 ZK 証明（Recursive ZK-proofs）についての記事を翻訳してほしいです。
かなり量があるので何回かに分けて翻訳をお願いします。

[翻訳の際の条件]
・わかりやすい日本語で翻訳してください。
・自然な日本語に訳してください。
・最後に要約をつけてください。

[入力]

[出力]

再帰的ゼロ知識証明（Recursive ZK Proofs、ZKP）についてご紹介します。再帰的 ZKP では、ある証明が別の証明の有効性を証明する仕組みを持ちます。標準的な非再帰的 ZKP に比べた利点を示し、具体例としてフィボナッチ数列の証明に応用します。

再帰的 ZKP とは
例えば、ペギーがビクターに来週一週間公園にいることをたった一枚の写真で証明したいとします。以下のようにできます：

1 日目、公園でカレンダーの日付を示した写真を撮る。
2 日目、公園で 1 日目に撮った写真を持ちながらカレンダーと共に写真を撮る。
3 日目、公園で 2 日目に撮った写真を持ちながらカレンダーと共に写真を撮る。
この手順を 7 日目まで繰り返し、最終的に一週間の滞在を一枚の写真で証明できます。

上記の比喩と同様に、再帰的 ZKP では、証明が他の証明の有効性を証明し、その証明がさらに別の証明の有効性を証明するという形になります。

再帰的 ZKP の必要性
再帰的 ZKP は標準的な ZKP に比べていくつかの顕著な利点があります。

集約
複数の証明を一つの証明に集約できます。この単一の証明は、構成するすべての証明が有効である場合にのみ有効であり、検証が非常に簡単です。特にブロックチェーン上での証明検証の際に魅力的です。何千もの証明を一つの証明に圧縮でき、検証コストを大幅に削減します。

並列証明生成
1,000 件のトランザクションが有効であることを証明したいとします。標準的な ZKP を使用すると、プローバーは 1,000 件のトランザクションを順次検証するために単一の証明を生成しますが、非常に時間がかかります。

再帰的 ZKP を使えば、各トランザクションごとに 1,000 件の証明を並行して生成できます。これによりプローバーの時間が大幅に短縮されます。これらの個々のトランザクション証明は上記のように再帰的に単一の証明に集約できます。

インクリメンタルな検証可能計算（IVC）
特定の計算の証明は、証明をインクリメンタルに更新する方が効率的です。

長い計算：非常に長い計算の証明は、プローバー側で大量のメモリを必要とします。一部の計算はメモリに収まりきらず、証明が不可能になります。
進化する計算：例えば、ブロックチェーンの状態を証明したい場合、それは常に成長しています。新しいブロックを検証するだけでなく、既存の証明自体も検証する新しい証明を計算します。
計算を小さなステップに分けて反復的に証明します。各ステップは、計算の現在の状態を証明する証明を含みます。再帰的 ZKP（特に IVC）を使用すると、現在のステップとその証明を使用して次のステップの新しい証明を再帰的に生成できます。証明の更新は、標準的な ZKP のように最初のステップから再計算する必要がなく、計算の総長に依存しません。

例えば、関数 F の計算を 0 から n まで次のように行うとします。

zᵢ は公開入力で、wᵢ は非公開入力（すなわち証人）です。z₀ から始めて最終出力が zₙ であることを効率的に証明したいとします。

IVC は、初期証明 𝛑₀ を生成し、それを各ステップでインクリメンタルに更新することでこれを実現します。例えば、𝛑₂ は F(z₁, w₁) = z₂ を証明するだけでなく、𝛑₁ が有効であることも証明します。帰納法により、最終的な 𝛑ₙ はすべての中間ステップが正しいことを証明します。

要約
再帰的ゼロ知識証明（ZKP）は、ある証明が他の証明の有効性を証明する手法です。これにより、複数の証明を一つに集約し、並列で証明生成を行うことが可能となり、長い計算や進化する計算の効率的な証明が実現します。具体例として、フィボナッチ数列の証明などがあります。

それはどのように機能するか
高レベルで言うと、SNARKs のようなゼロ知識証明（ZKP）は任意の計算を検証できます。SNARK の検証自体が計算であるため、SNARKs は他の SNARK 証明を検証することもできます。再帰的 SNARK 証明は、以前の有効な証明の存在を証明します。

具体的には、計算を SNARKs によって証明するためには、それを回路の形で表現する必要があります。検証者が検証鍵、証明、および公開入力を使って検証アルゴリズムを実行することを思い出してください。検証自体が計算であるため、それも回路で表現できます。この計算/回路に対する証明は、内部証明の有効性を認定します。この内部証明には別の証明が含まれることもあります。

ここまでは、理論的に再帰的 SNARKs がどのように機能するかを説明しました。実際には、検証はバイリニアペアリングなどの重い暗号操作を伴う集中的な計算です。そのため、効率的に動作させるためには楕円曲線のサイクルのような多くの新技術を採用する必要があります。この短いブログ記事ではこれらの実践的な問題には触れません。

フィボナッチの例
再帰的 SNARKs をフィボナッチ数列に適用してみます。フィボナッチ数列は次の漸化式で定義されます：

ペギーがビクターに数列の中にある数、例えば 55（F₁₀）を証明したいとします。彼らは再帰的 SNARKs のための TypeScript/JavaScript フレームワークである snarkyjs を使用します。

行 3〜38 で再帰的証明を定義します。行 11 で基本ケース fib0、行 18 で基本ケース fib1 を定義します。帰納的ケースは行 26 から始まります。行 31 と 32 で証明が再帰的に検証され、Fₙ の証明は Fₙ-₁ と Fₙ-₂ の証明が両方有効であり、かつその公式が従われている場合にのみ有効であることを示します。

行 41 で回路をコンパイルし、検証鍵を取得します。

ペギーは行 44 から 64 までの間に証明を反復的に生成します。

ビクターは検証鍵を使用して最終的な証明を検証します。注目すべき点は、彼が必要とするのは最終的な証明だけであり、行 50 で示されるようにシーケンスのインデックス N に関係なく数秒でそれを検証できるということです。

このおもちゃの例では、ビクターは N が 10 の時点で全体の数列を再計算して即座にそれを検証することもできます。再帰的 SNARKs の力は、N が例えば 1 兆のように大きい場合により明白になります。ビクターはそれでも証明を数秒で検証でき、再計算するよりも指数関数的に速くなります。

要約
再帰的ゼロ知識証明（ZKP）は、ある証明が他の証明の有効性を証明する仕組みを持ちます。これにより、複雑な計算を効率的に検証することが可能です。具体例としてフィボナッチ数列を用い、再帰的 SNARKs がどのように動作するかを説明しました。これにより、大規模な計算でも高速に検証できることが示されました。

以下、参考になるソースコード

```ts
import { SelfProof, Field, ZkProgram, verify } from "snarkyjs";

// フィボナッチ数列を表現するゼロ知識証明プログラムを定義します
let FibonacciSequence = ZkProgram({
  publicInput: Field,

  methods: {
    // フィボナッチ数列の基底ケースを定義します
    // fib_0 = 0
    // fib_1 = 1
    // これらの基底ケースには、それらの正しさを再帰的に検証するための証明が必要です
    fib0: {
      privateInputs: [],

      method(fib: Field) {
        fib.assertEquals(Field.zero);
      },
    },
    fib1: {
      privateInputs: [],

      method(fib: Field) {
        fib.assertEquals(Field.one);
      },
    },

    // 再帰的なフィボナッチ数列の定義
    inductiveFib: {
      privateInputs: [SelfProof, SelfProof],

      method(fib: Field, fib1: SelfProof<Field>, fib2: SelfProof<Field>) {
        // 再帰的な検証
        fib1.verify();
        fib2.verify();
        let newFib = fib1.publicInput.add(fib2.publicInput);
        fib.assertEquals(newFib);
      },
    },
  },
});

console.log("compiling ..");
// プログラムをコンパイルし、検証キーを取得します
const { verificationKey } = await FibonacciSequence.compile();
console.log("compiling finished");

// 証明の生成: 実際の計算を行って証明を生成します
let fib_n_2 = await FibonacciSequence.fib0(Field.zero);
let fib_n_1 = await FibonacciSequence.fib1(Field.one);
// フィボナッチ数列の公式 fibn = fibn-1 + fibn-2 に従います
let fib_n;
// fib_N の証明
const N = 10;
for (let n = 2; n <= N; n++) {
  console.log(`working on fib_${n}..`);
  let publicInput: Field = fib_n_1.publicInput.add(fib_n_2.publicInput);
  fib_n = await FibonacciSequence.inductiveFib(publicInput, fib_n_1, fib_n_2);

  fib_n_2 = fib_n_1;
  fib_n_1 = fib_n;

  console.log(`got fib_${n} = ${fib_n.publicInput.toString()}`);
}

// 検証: 検証者は最新の証明 fib_n のみが必要です
console.log("verify...");
let ok = await verify(fib_n, verificationKey);
console.log(`is ${fib_n.publicInput.toString()} in the sequence? ${ok}`);
```
